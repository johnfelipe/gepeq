/* OpenMark Authoring Tool (GEPEQ)
 * Copyright (C) 2013 UNED
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
package es.uned.lsi.gepec.model.entities;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;

import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.PrimaryKeyJoinColumn;
import javax.persistence.Table;
import javax.persistence.Transient;

//Generated 11-jun-2012 13:10:06 by Hibernate Tools 3.4.0.CR1

/**
 * QuestionsDragdrop generated by hbm2java
 */
@SuppressWarnings("serial")
@Entity
@Table(name = "questions_dragdrop", schema = "public")
@PrimaryKeyJoinColumn(name="id_question")
public class DragDropQuestion extends Question {
	private boolean infinite;
	private boolean forceBorders;
	private boolean shuffleDrags;
	private boolean shuffleDrops;
	private boolean clusteredDrags;
	private boolean clusteredDrops;

	public DragDropQuestion() {
		this(false, false, false, false, true, true);
		type = "DRAG_DROP";
		answers=new ArrayList<Answer>();
		addDraggableItem(new DragDropAnswer(),1);
		addDraggableItem(new DragDropAnswer(),1);
		addDroppableAnswer(new DragDropAnswer(),1);
		addDroppableAnswer(new DragDropAnswer(),1);
	}
	
	public DragDropQuestion(boolean infinite, boolean forceborders, boolean shuffleDrags, 
			boolean shuffleDrops, boolean clusteredDrags, boolean clusteredDrops) {
		super();
		this.infinite = infinite;
		this.forceBorders = forceborders;
		this.shuffleDrags = shuffleDrags;
		this.shuffleDrops = shuffleDrops;
		this.clusteredDrags = clusteredDrags;
		this.clusteredDrops = clusteredDrops;
	}

	@Column(name = "infinite", nullable = false)
	public boolean isInfinite() {
		return this.infinite;
	}

	public void setInfinite(boolean infinite) {
		this.infinite = infinite;
	}

	@Column(name = "forceborders", nullable = false)
	public boolean isForceBorders() {
		return this.forceBorders;
	}

	public void setForceBorders(boolean forceBorders) {
		this.forceBorders = forceBorders;
	}

	@Column(name = "shuffle_drags", nullable = false)
	public boolean isShuffleDrags() {
		return this.shuffleDrags;
	}

	public void setShuffleDrags(boolean shuffleDrags) {
		this.shuffleDrags = shuffleDrags;
	}

	@Column(name = "shuffle_drops", nullable = false)
	public boolean isShuffleDrops() {
		return this.shuffleDrops;
	}

	public void setShuffleDrops(boolean shuffleDrops) {
		this.shuffleDrops = shuffleDrops;
	}

	@Column(name = "clustered_drags", nullable = false)
	public boolean isClusteredDrags() {
		return this.clusteredDrags;
	}

	public void setClusteredDrags(boolean clusteredDrags) {
		this.clusteredDrags = clusteredDrags;
	}

	@Column(name = "clustered_drops", nullable = false)
	public boolean isClusteredDrops() {
		return this.clusteredDrops;
	}

	public void setClusteredDrops(boolean clusteredDrops) {
		this.clusteredDrops = clusteredDrops;
	}
	
	@Transient
	public DragDropAnswer getDraggableItem(int group,int position)
	{
		DragDropAnswer draggableItem=null;
		for (Answer a:answers)
		{
			if (a instanceof DragDropAnswer && ((DragDropAnswer)a).isDraggable() && 
				((DragDropAnswer)a).getGroup()==group && ((DragDropAnswer)a).getPosition()==position)
			{
				draggableItem=(DragDropAnswer)a;
				break;
			}
		}
		return draggableItem;
	}
	
	public void addDraggableItem(DragDropAnswer draggableItem,int group)
	{
		answers.add(draggableItem);
		draggableItem.setDraggable(true);
		draggableItem.setGroup(group);
		draggableItem.setPosition(getDraggableItems(group).size());
		draggableItem.setQuestion(this);
	}
	
	public boolean removeDraggableItem(int group,int position)
	{
		boolean ok=false;
		Answer toRemove=getDraggableItem(group,position);
		if (toRemove!=null)
		{
			ok=true;
			answers.remove(toRemove);
			
			// We renumber draggable items
			for (Answer draggableItem:getDraggableItems(group))
			{
				int draggableItemPos=draggableItem.getPosition();
				if (draggableItemPos>position)
				{
					draggableItem.setPosition(draggableItemPos-1);
				}
			}
		}
		return ok;
	}
	
	@Transient
	public DragDropAnswer getDroppableAnswer(int group,int position)
	{
		DragDropAnswer droppableAnswer=null;
		for (Answer a:answers)
		{
			if (a instanceof DragDropAnswer && !((DragDropAnswer)a).isDraggable() && 
				((DragDropAnswer)a).getGroup()==group && ((DragDropAnswer)a).getPosition()==position)
			{
				droppableAnswer=(DragDropAnswer)a;
				break;
			}
		}
		return droppableAnswer;
	}
	
	public void addDroppableAnswer(DragDropAnswer droppableAnswer,int group)
	{
		answers.add(droppableAnswer);
		droppableAnswer.setDraggable(false);
		droppableAnswer.setGroup(group);
		droppableAnswer.setPosition(getDroppableAnswers(group).size());
		droppableAnswer.setQuestion(this);
	}
	
	public boolean removeDroppableItem(int group,int position)
	{
		boolean ok=false;
		Answer toRemove=getDroppableAnswer(group,position);
		if (toRemove!=null)
		{
			ok=true;
			answers.remove(toRemove);
			
			// We renumber answers
			for (Answer answer:getDroppableAnswers(group))
			{
				int answerPos=answer.getPosition();
				if (answerPos>position)
				{
					answer.setPosition(answerPos-1);
				}
			}
		}
		return ok;
	}
	
	@Transient
	public List<Answer> getDraggableItems()
	{
		return getDragDropAnswers(true,0,false);
	}
	
	@Transient
	public List<Answer> getDraggableItems(int group)
	{
		return getDragDropAnswers(true,group,false);
	}
	
	@Transient
	public List<Answer> getDraggableItemsSortedByPosition()
	{
		return getDragDropAnswers(true,0,true);
	}
	
	@Transient
	public List<Answer> getDraggableItemsSortedByPosition(int group)
	{
		return getDragDropAnswers(true,group,true);
	}
	
	@Transient
	public List<Answer> getDroppableAnswers()
	{
		return getDragDropAnswers(false,0,false);
	}
	
	@Transient
	public List<Answer> getDroppableAnswers(int group)
	{
		return getDragDropAnswers(false,group,false);
	}
	
	@Transient
	public List<Answer> getDroppableAnswersSortedByPosition()
	{
		return getDragDropAnswers(false,0,true);
	}
	
	@Transient
	public List<Answer> getDroppableAnswersSortedByPosition(int group)
	{
		return getDragDropAnswers(false,group,true);
	}
	
	private List<Answer> getDragDropAnswers(boolean draggable,int group,boolean sortedByPosition)
	{
		List<Answer> answers=new ArrayList<Answer>();
		for (Answer answer:getAnswers())
		{
			if (answer instanceof DragDropAnswer && draggable==((DragDropAnswer)answer).isDraggable()
				&& (group<=0 || group==((DragDropAnswer)answer).getGroup()))
			{
				answers.add(answer);
			}
		}
		if (sortedByPosition)
		{
			// Note that we also group results by group if there are draggable items/answers of several groups
			Collections.sort((List<Answer>)answers,new Comparator<Answer>()
			{
				@Override
				public int compare(Answer a1,Answer a2)
				{
					int compareResult=0;
					DragDropAnswer dda1=(DragDropAnswer)a1;
					DragDropAnswer dda2=(DragDropAnswer)a2;
					if (dda1.getGroup()==dda2.getGroup())
					{
						compareResult=a1.getPosition()==a2.getPosition()?0:a1.getPosition()>a2.getPosition()?1:-1;
					}
					else if (dda1.getGroup()>dda2.getGroup())
					{
						compareResult=1;
					}
					else
					{
						compareResult=-1;
					}
					return compareResult;
				}
			});
		}
		return answers;
	}
	
	@Transient
	@Override
	public void setFromOtherQuestion(Question otherQuestion)
	{
		super.setFromOtherQuestion(otherQuestion);
		if (otherQuestion instanceof DragDropQuestion)
		{
			setInfinite(((DragDropQuestion)otherQuestion).isInfinite());
			setForceBorders(((DragDropQuestion)otherQuestion).isForceBorders());
			setShuffleDrags(((DragDropQuestion)otherQuestion).isShuffleDrags());
			setShuffleDrops(((DragDropQuestion)otherQuestion).isShuffleDrops());
			setClusteredDrags(((DragDropQuestion)otherQuestion).isClusteredDrags());
			setClusteredDrops(((DragDropQuestion)otherQuestion).isClusteredDrops());
		}
	}
}
